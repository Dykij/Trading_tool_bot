{
    "find_arbitrage_opportunities": {
        "body": "try:\n    perf_start = time.time()\n    logger.info(f\"Запуск поиска арбитража для {game_id}, диапазон цен: {price_from}-{price_to}\")\n    \n    # Получаем данные о рынке с параллельным выполнением, если включено\n    market_data = await self.get_all_market_items(\n        game_id=game_id,\n        price_from=price_from,\n        price_to=price_to,\n        max_items=max_items,\n        category=category,\n        use_parallel=True,\n        max_parallel_requests=5\n    )\n    \n    if not market_data or 'items' not in market_data or not market_data['items']:\n        logger.warning(f\"Не получены данные рынка для {game_id}\")\n        return []\n    \n    # Используем оптимизированный алгоритм группировки предметов по наименованию\n    # для быстрого поиска арбитражных возможностей\n    items_by_name = {}\n    total_items = len(market_data['items'])\n    logger.info(f\"Анализ {total_items} предметов для поиска арбитража\")\n    \n    # Группируем предметы по имени для эффективного сравнения\n    for item in market_data['items']:\n        name = item.get('name')\n        if not name:\n            continue\n        if name not in items_by_name:\n            items_by_name[name] = []\n        items_by_name[name].append(item)\n    \n    # Ищем возможности арбитража\n    opportunities = []\n    processed_count = 0\n    \n    for name, items in items_by_name.items():\n        processed_count += 1\n        if processed_count % 100 == 0:\n            logger.debug(f\"Обработано {processed_count}/{len(items_by_name)} уникальных предметов\")\n        \n        # Нужно минимум 2 предмета с разных площадок для арбитража\n        if len(items) < 2:\n            continue\n        \n        # Проверяем, есть ли предметы с разных площадок\n        markets = set(item.get('market', '') for item in items)\n        if len(markets) < 2:\n            continue\n        \n        # Сортируем предметы по цене (от дешевых к дорогим)\n        items.sort(key=lambda x: float(x.get('price', float('inf'))))\n        \n        # Проверяем каждую пару маркетов на возможность арбитража\n        for i, buy_item in enumerate(items):\n            buy_price = float(buy_item.get('price', 0))\n            buy_market = buy_item.get('market', 'Unknown')\n            \n            for sell_item in items[i+1:]:\n                sell_market = sell_item.get('market', 'Unknown')\n                \n                # Пропускаем, если предметы с одной площадки\n                if buy_market == sell_market:\n                    continue\n                \n                sell_price = float(sell_item.get('price', 0))\n                \n                # Учитываем комиссию площадки (допустим, 7%)\n                fee = 0.07\n                # Для предметов высокого спроса комиссия ниже\n                if 'liquidity_score' in sell_item and sell_item['liquidity_score'] > 7:\n                    fee = 0.02\n                \n                profit = sell_price * (1 - fee) - buy_price\n                profit_percent = (profit / buy_price) * 100 if buy_price > 0 else 0\n                \n                # Если прибыль выше минимального порога\n                if profit_percent >= min_profit_percent:\n                    # Вычисляем ликвидность\n                    liquidity = self._calculate_liquidity_score(sell_item)\n                    \n                    # Формируем результат\n                    opportunity = {\n                        'item_name': name,\n                        'buy_price': buy_price,\n                        'buy_market': buy_market,\n                        'buy_fee': 0,\n                        'sell_price': sell_price,\n                        'sell_market': sell_market,\n                        'sell_fee': fee,\n                        'profit': round(profit, 2),\n                        'profit_percent': round(profit_percent, 2),\n                        'buy_item_id': buy_item.get('id', ''),\n                        'sell_item_id': sell_item.get('id', ''),\n                        'liquidity_score': liquidity,\n                        'timestamp': int(time.time()),\n                        'risk_score': self._calculate_risk_score(buy_item, sell_item)\n                    }\n                    \n                    opportunities.append(opportunity)\n    \n    # Сортируем по соотношению прибыли и риска\n    opportunities.sort(key=lambda x: (x['profit_percent'] * (10 - x.get('risk_score', 5))), reverse=True)\n    \n    # Ограничиваем количество результатов\n    result = opportunities[:max_items]\n    \n    # Добавляем рекомендации по объемам торговли\n    for opp in result:\n        opp['recommended_volume'] = self._calculate_recommended_volume(opp)\n    \n    perf_time = time.time() - perf_start\n    logger.info(f\"Поиск арбитража завершен за {perf_time:.2f} сек. Найдено {len(result)} возможностей из {len(opportunities)} потенциальных.\")\n    \n    # Применяем ML-фильтрацию, если включено\n    if use_ml_filtering and self.use_ml and self.ml_predictor:\n        logger.info(\"Применение ML-фильтрации к результатам арбитража\")\n        result = self._apply_ml_filtering(result, market_data['items'], risk_threshold=0.6)\n    \n    return result\nexcept Exception as e:\n    logger.error(f\"Ошибка при поиске арбитражных возможностей: {e}\", exc_info=True)\n    return []",
        "args": "self, game_id: str, price_from: float = 0.0, price_to: float = 1000.0, min_profit_percent: float = 5.0, max_items: int = 100, category: Optional[str] = None, force_refresh: bool = False, max_path_length: int = 3, use_ml_filtering: bool = False, liquidity_threshold: float = 0.5",
        "returns": "List[Dict[str, Any]]"
    },
    "_calculate_risk_score": {
        "body": "# Вычисляем оценку риска на основе разных факторов\nrisk_score = 5.0  # Базовый уровень риска (1-10)\n\n# Фактор 1: Соотношение цен (слишком большая разница может указывать на ошибку)\nprice_ratio = buy_item.get('price', 0) / sell_item.get('price', 1) if sell_item.get('price', 0) > 0 else 0\nif price_ratio < 0.5:  # Если цена покупки менее 50% от цены продажи\n    risk_score -= (0.5 - price_ratio) * 10  # Снижаем риск\nelif price_ratio > 0.9:  # Если цена покупки более 90% от цены продажи\n    risk_score += (price_ratio - 0.9) * 50  # Повышаем риск\n\n# Фактор 2: Ликвидность предмета\nliquidity_score = sell_item.get('liquidity_score', 0)\nif liquidity_score > 7:  # Высокая ликвидность\n    risk_score -= 2\nelif liquidity_score < 3:  # Низкая ликвидность\n    risk_score += 2\n\n# Фактор 3: Разница во времени публикации (более новые предметы имеют меньший риск)\ntime_diff = abs(sell_item.get('_fetched_at', 0) - buy_item.get('_fetched_at', 0))\nif time_diff > 3600:  # Если разница больше часа\n    risk_score += 1\n\n# Фактор 4: История продаж\nsales_history = sell_item.get('salesHistory', [])\nif not sales_history:\n    risk_score += 1  # Нет истории продаж - повышенный риск\nelif len(sales_history) > 10:\n    risk_score -= 1  # Много продаж - сниженный риск\n\n# Ограничиваем оценку риска диапазоном 1-10\nrisk_score = max(1, min(10, risk_score))\n\nreturn risk_score",
        "args": "self, buy_item: Dict[str, Any], sell_item: Dict[str, Any]",
        "returns": "float"
    },
    "_calculate_recommended_volume": {
        "body": "# Базовый объем\nbase_volume = 1\n\n# Фактор 1: Прибыльность - больше прибыль, больше объем\nprofit = opportunity.get('profit', 0)\nif profit > 20:\n    base_volume += 2\nelif profit > 10:\n    base_volume += 1\n\n# Фактор 2: Риск - выше риск, меньше объем\nrisk = opportunity.get('risk_score', 5)\nif risk > 7:\n    base_volume = 1  # При высоком риске всегда ограничиваем 1 предметом\nelif risk < 3:\n    base_volume += 1  # При низком риске можно увеличить объем\n\n# Фактор 3: Ликвидность - более ликвидные предметы можно покупать в большем объеме\nliquidity = opportunity.get('liquidity_score', 0)\nif liquidity > 8:\n    base_volume += 2\nelif liquidity > 5:\n    base_volume += 1\n\n# Ограничиваем максимальный объем\nmax_volume = 5\nrecommended = min(base_volume, max_volume)\n\nreturn recommended",
        "args": "self, opportunity: Dict[str, Any]",
        "returns": "int"
    }
}