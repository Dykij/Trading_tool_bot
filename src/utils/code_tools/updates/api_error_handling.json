{
    "get_market_items_async": {
        "body": "try:\n    # Проверяем, не находится ли результат в кэше\n    cache_key = f'market_items_{game_id}_{limit}_{offset}_{currency}_{price_from}_{price_to}_{title}_{category}'\n    cached_result = await self.smart_cache.get(cache_key)\n    if cached_result:\n        logger.debug(f\"Возвращены кэшированные данные для запроса market_items_{game_id}\")\n        return cached_result\n    \n    # Уважаем ограничения API\n    await self._respect_rate_limit()\n    \n    # Формируем параметры запроса\n    params = {\n        'gameId': game_id,\n        'limit': limit,\n        'offset': offset,\n        'currency': currency\n    }\n    \n    # Добавляем опциональные параметры, если они указаны\n    if price_from is not None:\n        params['priceFrom'] = price_from\n    if price_to is not None:\n        params['priceTo'] = price_to\n    if title:\n        params['title'] = title\n    if category:\n        params['category'] = category\n    if rarity:\n        params['rarity'] = rarity\n    if exterior:\n        params['exterior'] = exterior\n    \n    # Выполняем запрос с повторными попытками при необходимости\n    result = await self._make_async_request('GET', '/market/items', params)\n    \n    # Обогащаем данные дополнительной информацией\n    if 'objects' in result and isinstance(result['objects'], list):\n        for item in result['objects']:\n            # Добавляем метку времени получения\n            item['_fetched_at'] = int(asyncio.get_event_loop().time())\n            # Вычисляем ликвидность, если есть необходимые данные\n            if 'inMarket' in item and 'salesPerDay' in item:\n                item['liquidity_score'] = self._calculate_liquidity_score(item)\n    \n    # Сохраняем результат в кэше\n    ttl = 300  # Кэшируем на 5 минут\n    await self.smart_cache.set(cache_key, result, ttl=ttl)\n    \n    return result\nexcept RateLimitError as e:\n    logger.warning(f\"Превышено ограничение API при запросе предметов: {e}\")\n    # Ждем немного дольше при ошибке превышения лимита\n    await asyncio.sleep(2.0)\n    raise\nexcept NetworkError as e:\n    logger.error(f\"Сетевая ошибка при запросе предметов: {e}\")\n    raise\nexcept Exception as e:\n    logger.error(f\"Непредвиденная ошибка при запросе предметов рынка: {e}\")\n    # Возвращаем пустой результат в случае ошибки\n    return {'objects': [], 'error': str(e)}",
        "decorator_list": "@retry_async(max_retries=3, factor=2.0, retry_exceptions=(RateLimitError, NetworkError))\n@cache_result(ttl=300)"
    }
}